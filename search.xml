<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客添加粒子时钟特效]]></title>
    <url>%2F2019%2F11%2F04%2Fhexo_clock%2F</url>
    <content type="text"><![CDATA[Hexo博客添加粒子时钟特效 博客应用canvas粒子时钟的操作步骤： 在\themes\next\layout\_custom\目录下，新建clock.swig文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264&lt;div style=&quot;&quot;&gt; &lt;canvas id=&quot;canvas&quot; style=&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt;(function()&#123; var digit= [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0] ]//: ];var canvas = document.getElementById(&apos;canvas&apos;);if(canvas.getContext)&#123; var cxt = canvas.getContext(&apos;2d&apos;); //声明canvas的宽高 var H = 100,W = 700; canvas.height = H; canvas.width = W; cxt.fillStyle = &apos;#f00&apos;; cxt.fillRect(10,10,50,50); //存储时间数据 var data = []; //存储运动的小球 var balls = []; //设置粒子半径 var R = canvas.height/20-1; (function()&#123; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成 data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); &#125;)(); /*生成点阵数字*/ function renderDigit(index,num)&#123; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; cxt.beginPath(); cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI); cxt.closePath(); cxt.fill(); &#125; &#125; &#125; &#125; /*更新时钟*/ function updateDigitTime()&#123; var changeNumArray = []; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); var NewData = []; NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); for(var i = data.length-1; i &gt;=0 ; i--)&#123; //时间发生变化 if(NewData[i] !== data[i])&#123; //将变化的数字值和在data数组中的索引存储在changeNumArray数组中 changeNumArray.push(i+&apos;_&apos;+(Number(data[i])+1)%10); &#125; &#125; //增加小球 for(var i = 0; i&lt; changeNumArray.length; i++)&#123; addBalls.apply(this,changeNumArray[i].split(&apos;_&apos;)); &#125; data = NewData.concat(); &#125; /*更新小球状态*/ function updateBalls()&#123; for(var i = 0; i &lt; balls.length; i++)&#123; balls[i].stepY += balls[i].disY; balls[i].x += balls[i].stepX; balls[i].y += balls[i].stepY; if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123; balls.splice(i,1); i--; &#125; &#125; &#125; /*增加要运动的小球*/ function addBalls(index,num)&#123; var numArray = [1,2,3]; var colorArray = [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;]; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; var ball = &#123; x:14*(R+2)*index + j*2*(R+1)+(R+1), y:i*2*(R+1)+(R+1), stepX:Math.floor(Math.random() * 4 -2), stepY:-2*numArray[Math.floor(Math.random()*numArray.length)], color:colorArray[Math.floor(Math.random()*colorArray.length)], disY:1 &#125;; balls.push(ball); &#125; &#125; &#125; &#125; /*渲染*/ function render()&#123; //重置画布宽度，达到清空画布的效果 canvas.height = 100; //渲染时钟 for(var i = 0; i &lt; data.length; i++)&#123; renderDigit(i,data[i]); &#125; //渲染小球 for(var i = 0; i &lt; balls.length; i++)&#123; cxt.beginPath(); cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI); cxt.fillStyle = balls[i].color; cxt.closePath(); cxt.fill(); &#125; &#125; clearInterval(oTimer); var oTimer = setInterval(function()&#123; //更新时钟 updateDigitTime(); //更新小球状态 updateBalls(); //渲染 render(); &#125;,50);&#125;&#125;)();&lt;/script&gt; 引用代码直接引用或者通过配置文件配置，二选一 直接引用在博客目录\themes\next\layout\_macro\sidebar.swig尾部中引入： 1&#123;% include &apos;../_custom/clock.swig&apos; %&#125; 示意图如下： 注：代码块要放置在sider-inner的div块中，放在div块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。 通过配置文件配置1、在博客目录\themes\next\layout\_macro\sidebar.swig尾部中引入： 1234&#123;% if theme.diy_time.clock %&#125; &lt;!-- canvas粒子时钟 --&gt; &#123;% include &apos;../_custom/clock.swig&apos; %&#125;&#123;% endif %&#125; 示意图如下： 注：代码块要放置在sider-inner的div块中，放在div块的位置决定时钟样式的展示位置。 2、在主题的配置文件中加入应用代码，配置文件位置是博客目录\themes\next\_config.yml： 1234# 侧栏粒子时钟diy_time: runtime: true clock: true # 粒子时钟 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Source Insight 4.0 破解和使用]]></title>
    <url>%2F2019%2F10%2F21%2FSouceInsight4%2F</url>
    <content type="text"><![CDATA[Source Insight 4.0 破解和使用 转自博客：https://blog.csdn.net/xiaoxu2050/article/details/82752799 Source Insight 4.0 破解安装第一步：安装 安装sourceinsight4.0 （可从下文地址下载）第二步：替换 用下文地址中的 sourceinsight4.0.exe 替换安装后路径下的 sourceinsight4.0.exe第三步：破解 运行sourceinsight4.0，选择破解文件破解 安装：如果需要全部重新安装，请下载 完全安装包+破解exe+lisence 压缩包： 12https://pan.baidu.com/s/1eSZtsbw 密码: 3kjj解压密码: biu 下载解压后先找到安装文件进行安装，然后用解压后的“source insight 4.0.exe”替换安装路径下的source insight 4.0.exe，然后运行SI4，在弹出的对话框中选择第三项并将下载的文件 si4.pediy.lic选中并“Next”即可破解！ 安装卸载附录：如果安装或者安装后提示有问题，请进行完全卸载后，再重装一遍即可。完全卸载方式： 1、清除注册表信息：“win ”+ R 或者 “开始” -&gt; “运行”，输入“regedit”，回车；在弹出的注册表管理器中，选择“编辑”-&gt; “查找”-&gt;“source insight”，或按照下述路径展开：HKEY_CURRENT_USER -&gt; software -&gt; Source Dynamics -&gt; Source Insight;将该项下面的source insight 需要清除的对应版本项目选中，右键“删除“。 2、删除全局配置信息：在 ./user/document/source insight 3.0/4.0 下的所有文件及该文件夹 注意此处的路径可能不同 也可能是:“库”-&gt;“用户”(也可能是你的名字) -&gt; 文档 -&gt; source insight3.0/4.0 或者 你上次安装的时候所指定的其他位置Source Insight4.0软件打开C程序中文注释乱码的解决方法更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。附录：source insight 安装序列号（如果以上没用） 123456SI3US-751793-52670SI3US-205035-36448SI3US-466908-65897SI3US-368932-59383SI3US-065458-30661SI3US-759512-70207 SourceInsight4.0的使用创建一个SI工程管理代码整体思路：告诉SI要解析哪些文件 -&gt; 告诉SI这些文件在哪 -&gt; 告诉SI文件选好了，解析它吧 。首先，这里演示的是C代码工程，其它编程语言也差不多。在解析C代码工程时，你可能希望SI连 .CC 和 .S结尾的文件也一同解析。那么点击 option -&gt; File Type Options -&gt; C/C++ Source File，我们在右边添加 .S;.cc。这里 *号是通配符，用英文;号隔开。代码类型设置 创建工程选择我们的代码工程位置，比如我选择了 D:\linux-to-windows-share\target 这个目录，我的工程代码全在这个目录下（注意不是SI的工程目录），然后点击 OK 继续。 导入项目点击Project-&gt;New Project。 点击Browse，选择你的源代码所在目录。 给新建的Source Insight工程取个名字，然后点击OK。 弹出窗口点击OK，然后点击Add Tree，添加目录结构下所有文件到工程。最后点击Close，项目就建立完成。 SynchronizeFile，双击Project Files窗口中的文件，即可打开文件，进行阅读或编辑。 新建一个项目快捷键Alt+Shift+N可以打开新建项目对话框，然后根据提示填好项目存储位置，源文件位置等，然后会出现添加删除项目文件对话框，选中自己想要编辑和浏览的文件添加即可，这样就建好了一个项目。 添加和删除项目文件（1）在添加删除文件前，可以先设置文件过滤器，菜单栏-选项-文档选项，就可以看到文件过滤器了，怎么设置应该是一目了然的。 （2）菜单栏-项目-添加或删除文件，即可打开添加和删除项目文件对话框。 同步文件 SynchronizeFile快捷键Alt+Shift+S可以同步文件，同步文件后就可以自动找到源代码之间的依赖关系了（如：可以自动找到调用某个函数或变量的位置） 项目报告菜单栏-项目-项目报告，获取当前项目的文件个数，代码行数等。 重建项目菜单栏-项目-重建项目，重新同步代码依赖关系。具体操作如下：依次点击 Project -&gt; new project ，弹出对话框分别是SI的 工程名字 和 工程目录，如：工程名QCA4020，目录名SI_Proj。 选择代码工程目录这一步，进一步确定你要添加哪些代码到你的SI工程中，如果你要添加 target 这个目录下的全部，就选中它，点击 Add Tree 就好。后面你要是增删文件，也在这里。添加好了，就点击 Close 吧。 添加以后，解析它吧。这一步会把代码加到SI数据库中，使得后面查找、关联更快。解析过程有点慢，耐心等待吧。点击Project -&gt; SynchronizeFile， 并选择1，3，4打钩（勾上会强制添加和解析），点击 start 。 解析代码如果解析完了，你突然发现忘记添加某些文件了，或者本来不用添加的你却添加了。不要担心，点击 Project -&gt; Add and Remove Project Files，再次进行添加删除，然后 再进行解析SynchronizeFile 操作才会生效。 添加和删除解析文件解析完，点一下那个书本一样的图标（Project Sympol List），尝试一下，你的代码就出来： SourceInsight 的窗口设置这里对SourceInsight进行一些设置，你完全可以不用设置，默认就好。 选择主题：Option -&gt; Visual Theme （选择你喜欢的）。设置字体大小：Option -&gt; Preference -&gt; Colors &amp; Fonts -&gt; Style -&gt; size 。 显示文件全路径：Option -&gt; Preference -&gt; Display ， 去掉 trim long path names with ellipes。 添加配置文件（别人配置好的）：Option -&gt; Load configuration（前提是你下载了别人的配置文件）。 显示行号：view -&gt; Line Numbers 。 使用技巧如果要 搜索字符位置，选中该字体，点击 工具栏的R图标 或者 Ctrl + F。 在Project Window（默认右边）的对话框中输入文件名，可以搜索到文件。 没有正确显示在右边的file list列表框需要在View菜单下找到Panels级联菜单下的Project Windows，把它勾选上。 Source Insight4.0软件打开C程序中文注释乱码的解决方法更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。 高亮显示选中的单词高亮显示：F8。取消高亮：再按一次F8。效果如下： 打开Source Insight相关窗口 （1）打开Symbol Window。View-&gt;Symbol Window。快捷键：Alt+F8。 （2）打开Context Window。View-&gt;Panels-&gt;Context Window。 （3）打开Relation Window。View-&gt;Panels-&gt;Relation WindowSource Insight窗口布局我一般设置如下： 窗口字体大小与样式设置步骤：Preferences-&gt;Colors&amp;Fonts-&gt;Set Panel Fonts and Colors。 这里设置只对上面窗口1：符号窗口（Symbol Window）和窗口4：项目文件夹浏览窗口（Project Folder Browser）有效，另外两个窗口无效。 窗口2：上下文窗口（Context Window）字体大小设置如下：在面板内右击-&gt;Context Window Options-&gt;scaling。 窗口3：引用关系窗口（Relation Window）字体大小设置如下： 窗口内右击-&gt;Relation Window Options-&gt;Font。Source Insight的7种窗口的使用。 1、文档窗口（1）、修改窗口颜色属性：菜单栏-选项-参数-颜色标签，可以修改背景颜色、默认字体颜色、修改标记颜色等，如背景颜色改为护眼模式：R199 G237 B204。 （2）、Alt+Y打开文档类型选项窗口，修改字体显示大小、是否显示行号、解析语言选择、工程文件过滤、扩展tab键、是否显示符号窗口等。 扩充1：Source Insight可以定义风格，菜单栏-选项-风格，即可以打开风格窗口，可以新建一个风格或修改一个风格。风格可以继承（和C++继承差不多）。 扩充2：如何使用风格。当选中某种语言解析文档的时候，可以定义一些固定字符以不同的风格显示出来。菜单栏-选项-参数-语言标签，选中解析文档的语言，点击关键字按钮，打开语言关键字窗口，在样式这一栏选中一种风格，然后添加关键字即可。这样文档中这个关键字就以那种风格显示了。 扩充3：如何查看和修改符号（如函数名、变量等）的风格，右击该符号，选择风格，打开窗口就可以看到该符号的风格是什么，然后进行修改。 （3）、快速更名ctrl+’，选中某个函数名，然后按ctrl+’，弹出快速更名窗口，然后根据相应的选项，可以快速更换函数名。（包括函数的声明处，定义处，引用处等）。 （4）、F8，高亮 （5）、ctrl+左击，进入函数定义或变量声明处。 （6）、Alt+，：后退 （7）、Alt+. ：前进 （8）、ctrl+g：调到固定行 （9）、Alt+左击拖动：可以进行列编辑 （10）、自动缩进：Alt+T打开文档选项窗口，点击自动选项，选中第三个smart缩进，并把后面的两个勾都去掉，这样配置比较好。可以尝试一下勾上的效果，然后和不勾的效果对比一下。 （11）、编码格式设置，设置完毕后需要重新打开文件进行浏览。 （12）、Ctrl+F打开查找界面，配置好查找选项，然后关闭查找界面，选中一个单词，按一次Shift+F3，然后只要按F3和F4即可进行查找上一个和下一个。 2、符号窗口这个窗口是显示文档的符号的，那么文档内容哪些是符号呢，这个应该是看文档窗口是设置哪种语言来解析文档的。 （1）、Alt+F8：打开/关闭当前文档的符号窗口。 （2）、Alt+Y打开文档选项窗口，配置所有文档是否打开符号窗口。 （3）、右击符号窗口-符号窗口选项-符号类型，可以选择显示的符号种类。 （4）、右击符号窗口-符号窗口选项，可以修改字体、背景颜色等。 3、项目窗口这个窗口可以使用各种模式来显示文件名、文件目录等。 （1）、右击窗口选项，修改字体或背景颜色、不显示文件大小、目录、日期等。 4、关联窗口这个窗口用来显示文档中的符号在哪些地方进行了引用。如哪些地方调用了函数，或该函数调用了哪些函数等。关联窗口可以有好多个。 （1）、右击关联窗口-窗口属性，可以修改字体、背景颜色等。 （2）、右击关联窗口-新建窗口，则可以打开一个新的关联窗口。 （3）、关联窗口的功能修改，右击关联窗口-窗口属性，可以修改对应符号的关系类型，选择Reference，则该窗口显示调用该函数或变量的地方，选择calls，则该窗口显示该函数调用了哪些函数。 （4）、如何使用该窗口：选中某个函数或变量，关联窗口会自动显示对于内容，如果不想它自己变，就锁上，然后需要找的时候刷新。（锁定、刷新按钮应该可以看到吧） 5、上下文窗口这个窗口一般配合关联窗口使用，单机关联窗口的某一项，可以自动在上下文窗口显示该项的上下文，双击上下文内容，则可以在文档窗口打开上下文。 （1）、右击窗口-属性，修改字体、背景颜色等。 6、剪辑窗口这个窗口的作用相当于是定义了好多粘贴板的意思。一个剪辑相当于一个粘贴板。 （1）、右击窗口-属性，修改字体、背景颜色等。 （2）、新建、修改、删除一个剪辑。 （3）、如何使用新建的剪辑：菜单栏-编辑-粘贴自剪辑/拷贝到剪辑。 7、代码片段窗口（1）、右击窗口-属性，修改字体、背景颜色等 （2）、可以自定义一些代码片段，使用时直接插入即可。 打开上下文窗口context window 在view / panels/ context window 三、自定义命令菜单栏-选项-自定义命令，可以添加一条命令，定义该命令的名字、执行命令语句。 如何运行命令：可以将命令显示在菜单栏（参考第五点菜单分配）或者给命令定义一个快捷键（参考第六点键分配）。 望君举一反三。 1、定义使用gvim打开当前文档的命令，前提是要先安装一个gvim程序。 12命令名：editWithGvim执行命令：&quot;C:\Program Files\Vim\vim63\gvim.exe&quot; --remote-silent +%l %f 备注：–remote-silent 是如果已经打开了对应文件，就不会打开第二次，而是在已经打开的文件里跳转到对应行；%l 是当前行；%f是当前文件。 2、在资源管理器中显示当前文档，即打开当前文档位置。 123命令名：explorer执行命令：explorer /select,%f备注：不知道，再说吧。 四、宏的使用宏语言是SourceInsight定义的一种可编程语言。安装好一个SourceInsight后，打开SourceInsight，可以看到有一个base项目。打开base项目，可以看到有一个Utils.em文件，该文件就是宏语言文件，在里面可以自己写一些宏，也可以新建一个.em文件写宏，或者下载一个别人写好的.em文件如quiker.em(lushengwen写的，用的人比较多)。新建的.em或别人的.em文件要加载到base工程中（如何加载：菜单栏-项目-添加/删除文件）。 如何调用宏：可以将宏显示在菜单栏（参考第五点菜单分配）或者给宏定义一个快捷键（参考第六点键分配）。 1、宏语言语法这个再说 2、quiker.em的使用（从网络下载）（1）、首先要把这个文件搞到手，然后将其加载到Base工程中，其次要定义一个快捷键调用quiker.em中的宏AutoExpand。quiker.em中写了那么多宏，为什么只调用AutoExpand宏就可以。因为调用AutoExpand宏后，AutoExpand会根据当前文本内容自动调用其他宏。一般情况下都用快捷键ctrl+enter调用AutoExpand宏。 （2）、输入文本config，然后执行AutoExpand，根据提示完成语言、姓名配置。 （3）、输入文本fu，然后执行AutoExpand，根据提示完成函数的注释。（在函数名的上一行执行） （4）、输入文本if，然后执行AutoExpand，可以自动完成语法。其他类似。 （5）、输入文本file，然后执行AutoExpand，可以自动生成.c文件描述。 （6）、输入文本hdn，然后执行AutoExpand，根据提示完成.h文件宏定义。 （7）、在.c文件里输入hd，然后执行AutoExpand，可以自动生成.c文件对应的头文件。 （8）、后续补充 3、自己写的宏（1）、自动注释，给这个宏定义一个快捷键，然后选中几行文本，执行快捷键，即可以进行注释与反注释操作。 12345678910111213141516171819202122232425262728293031macro MultiLineComment()&#123; hwnd = GetCurrentWnd() selection = GetWndSel(hwnd) LnFirst =GetWndSelLnFirst(hwnd) //取首行行号 LnLast =GetWndSelLnLast(hwnd) //取末行行号 hbuf = GetCurrentBuf() if(GetBufLine(hbuf, 0) ==&quot;//magic-number:tph85666031&quot;)&#123; stop &#125; Ln = Lnfirst buf = GetBufLine(hbuf, Ln) len = strlen(buf) while(Ln &lt;= Lnlast) &#123; buf = GetBufLine(hbuf, Ln) //取Ln对应的行 if(buf ==&quot;&quot;)&#123; //跳过空行 Ln = Ln + 1 continue &#125; if(StrMid(buf, 0, 1) == &quot;/&quot;)&#123; //需要取消注释,防止只有单字符的行 if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123; PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf))) &#125; &#125; if(StrMid(buf,0,1) !=&quot;/&quot;)&#123; //需要添加注释 PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf)) &#125; Ln = Ln + 1 &#125; SetWndSel(hwnd, selection)&#125; 五、菜单分配菜单栏-选项-菜单分配，可以将自定义命令、宏等显示到菜单栏列表里。 六、健分配菜单栏-选项-键分配，定义快捷键，可以将自定义命令、宏等定义一个快捷键。 七、配置的保存和载入菜单栏-选项-载入配置或保存配置，可以把自己的配置保存下来，或者发给别人让别人使用。获取我的配置文件：http://pan.baidu.com/s/1pKViFHp。 八、布局使用软件提供了四个布局的保存，当配置好一个界面布局后可保存到一个布局当中，这样可以方便切换软件布局。 九、文件名标签设置为最近的使用靠左显示 10、显示/去掉overview附：代码格式化，自己调整，本来想上传配置文件的，我看还是算了，自己调整吧 面是SI4.0版本官网的使用说明介绍网页。https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.html 附简易使用说明：Source Insight导入源代码流程如下： 1）打开Source Insight； 2）选择Project-&gt;New Project，填写工程的名字，工程文件存放路径，点击OK后即创建Source Insight工程相关文件(相应目录会生成*.PR等工程文件)； 3）不断Next，你会发现Add and Remove Project Files对话框，在左边列表中选择你的源代码所在的文件夹，然后点击Add Tree，将源代码中所有文件添加到新创建的Source Insight工程中(即添加到右边列表中)，添加完成后你可以关闭该对话框，点击Project-&gt;Rebuild Project,这时你的源代码中的所有源文件全部都同步到Source Inight工程中了，这时你就可以使用Source Insight阅读源代码了；点击Project-&gt;New Project，就会出现以下界面 再New project name里面写一个项目名字，然后点击Browse，选择到你那个项目的文件夹，此次以我的一个项目为例： 点击确定，然后出现一直ok 直到出现这个界面 然后点击Add Tree，出现这个界面 点击确定，然后出现这个界面 ，然后把这个界面关掉就加载了项目 然后点击右边操作栏中，下面被选中这个按钮 然后会弹出一个提示框，是否要将这些代码关联，确认，然后加载完就可以，此时出现的是所有识别的函数名的列表，然后点击第一个按钮，回到下面这个界面，显示的是文件代码 双击其中Main.cpp文件，出现这个界面 然后随便选择这个文件中一个函数，就可以在下面看到他的定义 下面查看这个函数的全部调用，右击这个函数，选择Lookup References 然后选择Search 如果有弹出下面的框，可以随便选择Replace还是Append 然后就出现下面的界面 来源：https://blog.csdn.net/biubiuibiu/article/details/78044232https://www.jianshu.com/p/adca6c2f94f6https://blog.csdn.net/qq_39660930/article/details/77499455https://baijiahao.baidu.com/s?id=1608656406591755295&amp;wfr=spider&amp;for=pchttps://zhuanlan.zhihu.com/p/32754019https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.htmhttps://zhuanlan.zhihu.com/p/36543793 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置（二）]]></title>
    <url>%2F2019%2F09%2F20%2Ftheme_NextConfig2%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置（二） 随机背景图片加载原理自动更换背景是修改添加背景的css样式实现 图片来源https://source.unsplash.com/ 修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码： 1234567body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; 参数细节url可更换为自己喜欢的图片的地址。repeat：是否重复出现attachment：定义背景图片随滚动轴的移动方式position：设置背景图像的起始位置。background-size:cover为可能有助于大分辨率下背景图的显示 修改不透明度（可加可不加，看实际效果）因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。 调整背景的不透明度可以更加美观，参数opacity:建议调整0.8至0.95之间。修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码 1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.9; min-height: 500px;&#125; 其中：background: #fff; 白色opacity: 0.9;为不透明度 注：效果还可以，但是博客备份在github上，网速限制加载的比较忙，建议博客放在国内的Coding上 固定背景图片加载hexo\themes\next\source\images\ 的路径下；在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。 修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，添加以下代码： 1234567body &#123; background:url(/images/图片.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; 侧边栏社交小图标设置侧边栏默认只有打开主题配置文件（_config.yml），搜索social_icons:,在fontawesome图标库（网址）找自己喜欢的小图标，并将名字复制在如下位置配置文件 12345678910111213social: GitHub: https://github.com/yourname || github E-Mail: mailto:邮箱地址 || envelope Weibo: https://weibo.com/yourname || weibo CSDN: https://me.csdn.net/yourname || book #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设置网站图标下载图标图标网站 下载尺寸32 X 32的图标，文件名必须是favicon.ico。 图标放在2.将图标放在下一个/源极/图像文件夹目录下面。 配置3.配置主题目录中的配置文件（敲黑板，重点） 之前网上查到的方法如下:(并没有成功） 放大文章内图片使用了图片浏览放大功能fancybox插件插件地址 下载插件安装包下载插件安装包到blog的lib目录 1$ cd themes/next 1$ git clone https://github.com/theme-next/theme-next-fancybox source/lib/fancybox 注意删掉fancybox文件夹里的 .git``.github文件夹 更改主题配置文件更改next/_config.yml文件 1fancybox: true]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone11 信息汇总]]></title>
    <url>%2F2019%2F09%2F11%2Fiphone11%2F</url>
    <content type="text"><![CDATA[北京时间9月11日，iPhone 11 系列正式发布，此次共有三款新机，分别是iPhone 11，iPhone 11 Pro，iPhone 11 Pro Max。 说明：笔者不对今年新款iPhone做评价，仅做简单陈述，无意贬低苹果或者其他友商，最后总结参考自PConline。 市场反响关注程度高不得不说虽然许多人称今年苹果发布会毫无新意，但是不得不说苹果关注度依然居高不下，这也说明苹果在手机界的影响力依然存在：苹果发布会第二天早上微博热搜前十苹果相关占6个 9月11日报道：iPhone 11天猫预约量暴增200％,绿色预约量最高源报道地址 外观：换色，换摄 没有任何意外，iPhone 11系列包含了三款产品，iPhone 11、iPhone 11 Pro以及iPhone 11 Pro Max。首先看看比较贵的两款机型，iPhone 11 Pro和iPhone 11 Pro Max，他们将是今年与安卓旗舰对标的主力。 &nbsp;&nbsp;不过官方公布的iPhone 11图片显然比之前曝光的iPhone图片要好看，而且虽然大致形状已经被提前剧透，但是实际iPhone 11外观依然与之前曝光的有所差距. 曝光图1:曝光图2:发布会图片1:发布会图片2: &nbsp;&nbsp;机身正面设计，iPhone 11 Pro和iPhone 11 Pro Max给人的第一观感与上代机型几乎完全没有区别，同样的OLED材质、同样的窄边框设计、还有同样的刘海。 &nbsp;&nbsp;还好，用了两年刘海设计的iPhone还是凭借与边框几乎同宽的底边维持了耐看感，仔细揣摩，iPhone 11 Pro系列还是有了少许的升级，比如说，更强的屏幕，依旧是5.8英寸和6.5英寸，苹果将其称为“Super Retina XDR”的屏幕，458ppi，支持HDR、1200nit的峰值亮度，更高的对比度表现。 &nbsp;&nbsp;至于走量机型iPhone 11，毫无意外地维持Liquid Retina的LCD屏幕，虽然分辨率和旗舰手机会有点距离，但屏幕素质依旧出色，让用户“心甘情愿”为LCD埋单，屏幕尺寸为6.1英寸，刘海没有变小，与iPhone XR区别不大。 &nbsp;&nbsp;来到背面，全新iPhone 11系列在视觉上最大的变化就在这里，提供金色、深空灰色、银色、暗夜绿色共四色。3年的时间，苹果终于迈出了从双摄到三摄的一步。iPhone 11 Pro和iPhone 11 Pro Max均搭载后置三摄，虽然还是“祖传”1200万像素，但功能和外观有了不少的升级，至于这个“浴霸”外观，大家见仁见智吧。 走量机型iPhone 11终于让新iPhone全系多摄化，双摄加入，搭配多彩的机身设计，相信能够接下iPhone XR传来的一棒。 足足6种配色，iPhone 11让质感和设计并存：白色、黑色、红色、黄色，新加入的紫色、今年大热的绿色，当然也没有缺席。 全新iPhone 11系列的登场，给人感觉在外观方面少了一点惊喜：纵然浴霸外观革新了沿用两年的iPhone X系列设计；更小的刘海带来高屏占比，但都没有离开“稳扎稳打”的主旋律。 拍照：二摄/三摄 近几年，iPhone新品都重点在摄像头上面做文章，这次苹果iPhone 11 Pro与iPhone 11 Pro Max也不例外，相机硬件与软件体验全面升级，而两者的摄像头硬件配置一样。以前置摄像头为例子，配备了12MP TrueDepth镜头，支持全新升级慢动作视频和前置4K 60fps摄像，并支持人像模式。 后摄方面，三摄成员的一边，iPhone 11 Pro/iPhone 11 Pro Max的后置摄像头拥有全新的传感器，搭配1200万像素（广角，F/1.8，六镜式镜头）+1200万像素（长焦，F/2.0，六镜式镜头）+1200万像素（120°超广角，F/2.4，五镜式镜头 ）的组合，支持最高2倍光学变焦，广角与长焦镜头都搭载光学防抖，而在同一地方拍摄的时候，可以拍出三种不同的画面。 iPhone 11样张 软件方面，拥有人像模式，焦外成像和景深控制，以及人像光效，支持六种效果 (自然光、摄影室灯光、轮廓光、舞台光、单色舞台光和高调单色光)。大家期待的夜间模式，这次也终于配备。 如果你过去对iPhone的拍摄界面枯燥，这次应该会惊喜，苹果带来全新更具美感的沉浸式界面。 利用摄像头宽广的视角，可以看到取景框外的画面，体验更佳。 全新三摄系统 据了解，当苹果设计iPhone Pro摄像头的时候，希望超广角、广角与长焦这三个摄像头能同时运作。为了让不同模块呈现一致的效果，对每个摄像头的白平衡和曝光等参数，工程师都单独进行精确调校。 iPhone 11样张 在切换长焦、广角和超广角的流畅切换过程当中，利用了A13仿生运算能力。通过iPhone团队的合作，调校三摄协作的风格统一，大大提升相机的拍摄性能。 广角是这次iPhone 11 Pro家族的一大提升，取景范围高达四倍的超广角摄像头，可拍摄气势磅礴的场景，不论是妹子的大长腿，还是壮丽的山河景色，都可以尽收眼底。 4K视频 在A13处理器的协助下，iPhone 11 Pro支持扩展的动态范围和影院级防抖功能，可以录制4K 60fps的视频，而且后期剪辑工具也更好玩。 夜间模式 新的广角摄像头传感器让大众期待的“夜间模式得以实现”，通过智能的软件和A13仿生，用户只需要按下快门，就会自动生成明亮的画面效果，无惧黑夜。 左：未开启夜景模式 右：开启夜景模式 当系统检测到光线环境暗的时候，夜间模式会自动开启，借助光学防抖功能，拍摄多张这篇最终合成一张，类似安卓厂商宣传的多帧合成功能，例如在昏暗的晚宴，或者是光线环境一般的室外。 人像模式 在摄像头虚化方面，苹果一直领先不少安卓机型，而这次三个摄像头配合，广角可以拍摄更独特的样张，而当使用iOS 13的时候，里面有增加高调单色光效果，单色照符合个性鲜明的用户需求。 iPhone 11 Pro样张 苹果再次升级了智能HDR功能，称为“下一代智能HDR”，通过更灵敏的感光元件、增强的图像信号处理器和先进的算法，让照片中的高光和阴影细节更丰富。全新传感器拥有更低的弱光画面噪点，细节更丰富，优于前辈机型。 硬件：A13 Bionic/全系双卡/18W快充 Apple Arcade作为开场，性能无疑是苹果今年新设备的重点。 事实上，A系列处理器的强悍，确保了每年新iPhone在价格领先的同时也保持了性能领先。今年的新机照旧是“故技重演”，iPhone 11系列全系搭载全新的A13 Bionic处理器，配备神经网络引擎，继续发力苹果重视AR功能和AI体验。 旗舰处理器竞争已经不是当初两家之战，今年A13自然是卯足了劲。 A13 A13 Bionics采用4颗效率核心+2颗性能核心的组合，搭配4核心GPU，集成85亿个晶体管，性能提升了大约20％ 。苹果称其为“智能手机中最快的CPU”，有着“智能手机中最快的GPU”。 A13 Bionics搭载全新的人工智能核心Neural Engine，Apple表示该芯片的机器学习（ML）性能大幅提升，8核神经引擎能够执行1万亿每秒运算，“带来6倍性能升级。AI表现更加强大，无需让A13处理器“小材大用”，实现更出色的功效表现。当然，凭借苹果的优化，这些提升都会“无声无息”体现在你的日常体验里面。 由于现在iPhone未发售，所以也没有可靠的跑分，所以就拿发布会的几张图片分析一下：9月12日更新GeekBench跑分 发布会公布的对比图(苹果首次对比华为)：CPU对比： 笔者注：上图中CPU的对比应该是对比了单核性能差距(单核性能苹果与安卓阵营差距明显），多核性能差距并没有图中这么明显GPU对比： GeekBench 4跑分对比： &nbsp;&nbsp;为了更加直观地了解这款芯片，我们来看一下骁龙855和骁龙855 Plus移动平台在Geekbench上的跑分表现。根据此前信息，小米9搭载的骁龙855移动平台在Geekbench 4上的单核跑分为3518分，多核跑分为11174分；黑鲨游戏手机2 Pro搭载骁龙855 Plus移动平台，在Geekbench 4上的单核跑分成绩为3632分，多核跑分成绩为11304分，华为P30所搭载的麒麟980移动平台，在Geekbench 4上的单核跑分成绩3390分，多核跑分成绩达到10318分。&nbsp;&nbsp;由此可见，A13芯片无论是单核跑分还是多核跑分都要比骁龙855系列移动平台更高一些，表现确实更加优秀。根据官方介绍，苹果在三年半前就开始研发这款芯片，A13是iPhone迄今为止最快的芯片，与历代iPhone相比，无论是在CPU还是GPU方面，都有着很大的提升。 &nbsp;&nbsp;顺便说一下，许多人说没有对比麒麟990，但是麒麟990依然使用Cortex-A76架构的大核和Mali-G76的GPU，并未采用Cortex-A77+Mali-G77（明年的高通865和三星已经官宣的Exyons980都采用了这一架构），而官方说法是A77架构能够提升20%的同频性能。因此华为990与980（同样采用Cortex-A76架构的大核和Mali-G76的GPU）差距并不大，主要是频率差异，官方说法是在整体性能表现会比上麒麟980提升10%左右，因此A13在CPU和GPU方面超越990是没问题的，当然5G就是另一回事了。 续航/充电 续航方面，iPhone 11系列的三台手机均提供不同程度的提升，iPhone 11 Pro Max较上代提升高达5小时续航、iPhone 11 Pro和iPhone 11则比他们的前辈iPhone XS和iPhone XR分别提升4小时和1小时续航，在提供强大性能的同时，带来更持久的使用体验。 说到续航，不得不提的就是iPhone历年被吐槽的充电，虽然发布会上没有说，但苹果官网消息显示，iPhone 11 Pro系列随附 18 瓦电源适配器，快充状态下约 30 分钟可充至 50% 电量；iPhone 11同样支持18W有线快充，官网特别提醒需使用 18 瓦或更大功率的电源适配器 (需单独购买)。 值得一提的是，今年的国行iPhone 11/iPhone 11 Pro和iPhone 11 Pro Max全系支持双卡功能，对于在上代iPhone XS纠结没有双卡的用户，这次大可放心入手较小屏幕的旗舰版本。 价格&nbsp;&nbsp;价格方面，iPhone 11国行起售价64GB版5499元；128GB版5999元；256GB版6799元。iPhone 11 Pro售价为64GB版8699元；256GB版9999元；顶配512GB版11799元，iPhone 11 Pro Max售价为64GB版9599元；256GB版10899元；顶配512GB版12699元。新机将在9月13日开始预购，9月20正式发售。iphone11与去年iPhone XR相比降了1000元。iPhone 11 Pro和iPhone 11 Pro Max则是与去年iPhone XS 和iPhone XS Max价格一致，考虑到iPhone 11 的美国价格是699美元，如果算上13%的增值税，应该会超过5500，因此今年iPhone 11的价格应该是针对中国市场作了调整（其余两款则保持原价）。因此与去年的iPhone XR相比iPhone 11加量还减价就显得性价比比较高了，如果不急着买，算上双11之类的促销最后应该可以5000以下拿下，性价比不错，相对应的iPhone XR的官网价格则下调到了4799。相比首发价下调1700，有需要的可以考虑。 总结 尽管升级不少，但全新的iPhone 11系列，却不能像以往那样给人一种打在安卓旗舰身上“拳拳到肉”的感觉，缺了什么呢？答案大家可能都知道，没有5G，或许会成为苹果今年挽回销量的一道坎。 5G永远在骚动，iPhone有恃无恐。今年的iPhone 11系列还能在5G前夕挽留人们的偏爱吗，还会出现“境泽言香”的局面吗？相信不久后，销量会告诉我们答案。 官网链接苹果官网介绍 附注&nbsp;&nbsp;本文图片来自网络，部分内容参考自PConline。]]></content>
      <tags>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F09%2F08%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown基本语法，适用Github,简书，Reddit等 主要内容 Markdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 Markdown相比WYSIWYG编辑器 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： &gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); }注意:需要和普通段落之间存在空行。 4.5 字体在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_要倾斜的文字左右分别用一个*号包起来 **粗体**，__粗体__要加粗的文字左右分别用两个*号包起来 ***斜体加粗***要倾斜和加粗的文字左右分别用三个*号包起来 ~~删除线~~要加删除线的文字左右分别用两个~~号包起来 效果： 斜体，斜体粗体，粗体这是斜体加粗的文字这是加删除线的文字 4.6 列表(表格)使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格或制表符_。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown MarkDownCopy https://github.com/younghz/Markdown 关于其它扩展语法可参见具体工具的使用说明。]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
        <tag>规范</tag>
        <tag>reddit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置]]></title>
    <url>%2F2019%2F09%2F08%2Ftheme_NextConfig1%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置 新建404界面在站点根目录下，输入hexo new page 404，在默认Hexo站点下/source/404/index.md打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态资源压缩静态资源压缩 在站点目录下安装插件： 1$ npm install gulp -g 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在Hexo站点下添加gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器： 123hexo ggulphexo d 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用&lt;!--与--&gt;隐藏之间的代码即可，或者直接删除。位置如图： 各版块透明度修改内容板块透明根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.content-wrap标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.header-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 站点概况背景根博客目录themes\next\source\css\_schemes\Pisces\_sidebar.styl文件.sidebar-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 修改然后根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.sidebar标签下background: $body-bg-color修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 网站底部字数统计具体方法实现 切换到根目录下，然后运行如下代码 1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可： 12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前： 123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 网页底部信息隐藏网页底默认最新一次使用，需要取消since注释，设定年份 1234567891011121314151617footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, `author` from Hexo main config will be used. copyright: by AomanHao #版权 显示文章阅读进度百分比设置方法：打开themes/next/_config.yml主题配置文件,找到# Scroll percent label in b2t button将scrollpercent:的值,改成true 12# Scroll percent label in b2t button scrollpercent: true 浏览页面的时候显示当前浏览进度如果想把top按钮放在侧边栏,打开themes/next下的_config.yml,搜索关键字b2t,把false改为true 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 1234567891011121314# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: appkey: notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page Hexo添加阅读次数next 集成了 leancloud 。可以在leancloud进行账号注册。创建一个新的应用。点击应用进入。创建名称为Counter的Class，名称必须为Counter 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next_config.yml打开主题配置文件 添加app_id 和app_key: 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: app_key: # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false Web安全性为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。 显示文章热度首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 设置方法：next主题集成leanCloud，打开themes/next/layout/_macro/post.swig,准备添加℃ 1234567891011121314&#123;# LeanCloud PageView #&#125;&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 插入摄氏度到倒数第三句，如下： 1&lt;span&gt;℃&lt;/span&gt; 打开，themes/next/languages/zh-CN.yml,将views后的文字描述改为热度. 1views: 热度 有的版本不一样，打开，themes/next/languages/zh-Hans.yml，将以下 1visitors: 热度 然后打开themes/next/_config.yml找到leancloud_visitors,将enable:改成true,再填上自己LeanCloud的app_id和app_key。 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: 你自己的id app_key: 你自己的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false 添加网站已运行时间在themes/layout/_parrials/footer.swing后添加 1234567891011121314151617&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("11/27/2017 12:00:00");//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = " Runing "+dnum+" D "; document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S"; &#125; setInterval("createtime()",250);&lt;/script&gt; 添加头像打开themes/next下的_config.yml文件，搜索 Avatar关键字，修改url的参数 1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url链接默认是themes/next/source/images下的avatar.gif文件,有两种方法修改连接 1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间 12345url: /images/avatar.gif或者url: /images/xx.jpg等类型图片 2、图床外链，建议使用 1url: http://example.com/avatar.png 添加站内搜索设置效果： 设置方法：安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 底部跳动图标实现注意点：需要到next\layout_partials下的footer.swig文件中，在你所需要调动的图标所对应的span中增加对应的ID去到主体的css文件（next\source\css_variables\custom.styl，增加以下代码即可 123456789101112131415//底部爱心小图标跳动keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;//图标所对应的span中的ID#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 113);&#125; 实现统计功能具体实现方法:在根目录下安装 hexo-wordcount,运行： 1npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css\_custom的custom.styl添加下面参数 12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大数据算法排序]]></title>
    <url>%2F2019%2F09%2F06%2F10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C%2B%2B%2F</url>
    <content type="text"><![CDATA[语言：Java、C++ 排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 用一张图概括： 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 1. 冒泡排序1.1 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1.2 动画演示 1.3 参考代码1234567891011121314151617181920212223242526272829// Java 代码实现public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 2. 选择排序2.1 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2.2 动画演示 2.3 参考代码123456789101112131415161718192021222324252627282930//Java 代码实现public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 3. 插入排序3.1 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 3.2 动画演示 3.3 参考代码123456789101112131415161718192021222324252627282930//Java 代码实现public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 4. 希尔排序4.1 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动画演示 4.3 参考代码1234567891011121314151617181920212223242526272829//Java 代码实现public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 5. 归并排序5.1 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 5.2 动画演示 5.3 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; C++代码：cankao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn=500000,INF=0x3f3f3f3f;int L[maxn/2+2],R[maxn/2+2];void merge(int a[],int n,int left,int mid,int right)&#123; int n1=mid-left,n2=right-mid; for(int i=0;i&lt;n1;i++) L[i]=a[left+i]; for(int i=0;i&lt;n2;i++) R[i]=a[mid+i]; L[n1]=R[n2]=INF; int i=0,j=0; for(int k=left;k&lt;right;k++) &#123; if(L[i]&lt;=R[j]) a[k]=L[i++]; else a[k]=R[j++]; &#125;&#125;void mergesort(int a[],int n,int left,int right)&#123; if(left+1&lt;right) &#123; int mid=(left+right)/2; mergesort(a,n,left,mid); mergesort(a,n,mid,right); merge(a,n,left,mid,right); &#125;&#125;int main()&#123; int a[maxn],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; mergesort(a,n,0,n); for(int i=0;i&lt;n;i++) &#123; if(i) cout&lt;&lt;" "; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 6. 快速排序6.1 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 6.2 动画演示 6.3 参考代码Java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041//Java 代码实现public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; C++代码：cankao 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;int main()&#123; int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k; int len=sizeof(array)/sizeof(int); cout&lt;&lt;"The orginal arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; quickSort(array,0,len-1); cout&lt;&lt;"The sorted arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; system("pause"); return 0;&#125; void quickSort(int s[], int low, int high)&#123; if (low&lt; high) &#123; int i = low, j = high, x = s[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quickSort(s, low, i - 1); // 递归调用 quickSort(s, i + 1, high); &#125;&#125; 7. 堆排序7.1 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 7.2 动画演示 7.3 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Java 代码实现public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 8. 计数排序8.1 算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 8.2 动画演示 8.3 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142//Java 代码实现public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 9. 桶排序9.1 算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果 9.2 动画演示 9.3 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Java 代码实现public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 10. 基数排序10.1 算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 10.2 动画演示 10.3 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Java 代码实现public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2019%2F09%2F05%2FC%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[C++入门 指针入门 指针作用： 引用类型，传递地址，减少内存消耗案例int p &gt;定义变量pint* p &gt;定义指针变量p使用指针，先要定义指针变量 12345678#include&lt;stdio.h&gt;int main() &#123; int *p; //int* p &gt;定义指针变量p int a=3; p=&amp;a; //&amp;a是把a的地址赋给指针p，&amp;：取址符a printf(&quot;%d\n&quot;,*p) //输出为3 return 0; &#125; 123&amp; 取变量的地址 &amp;(变量名)* 指针运算符（取值运算） *(变量名)&amp; *互为逆运算 *(&amp;(int i =6))=6 指针变量是存储地址的变量，随机分配例如： 123456int *p1;char *nameint x;int *p; p=&amp;x;答：*P=3;p是x的地址，*p是x的值 常用错误：1、指针不能直接复制 123456789错误：int *p; p =100;//错误正确：int i, *p, *t;p=&amp;i;t=p;*p *t是指针，把i的地址赋给pt指针（元素地址） 2、不能直接给指针赋值(不能直接变量取值) 12int x= 20;printf(&quot;%d,&amp;(*x)); Scanf函数:函数后的参数应该传入指针，不应该是值 123int score;printf(&quot;shuru :\n&quot;);scanf(&quot;%d&quot;,score); Swap函数： 12345678910111213141516171819#include&lt;stdio.h&gt;void swap(int *x, int *y)&#123; int temp;//中间变量 temp=*x; *x = *y; *y = temp; printf(&quot;x=%d, y=%d \n&quot;, *x, *y);&#125;main()&#123; int i =13, j =45; swap(&amp;i, &amp;j); printf(&quot;i=%d, j=%d\n&quot;,i ,j);&#125;//输出： x=45,y=13 i=45,j=13 二级指针 C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。只有一个号的时候，我们叫它一级指针。* 两个星号的叫二级指针。 123456789101112131415void swap ( int *a, int *b )&#123; int c; c = *a; *a = *b; *b = c; &#125; int main(int argc, char **argv)&#123; int a,b; a = 16; b = 32; swap( &amp;a, &amp;b); return ( a - b ); &#125; 段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数 我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下 12345p中放的是中间桥梁bridge的地址&amp;bridge*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，**p就是目标操作数中间的bridge是桥梁，中间件使用的，过度吧 双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。 输入输出流IO库：|头文件|类型||||-|-|-|-||iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流||fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件||sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string| 123类型ifsream和istringstream都继承自istream;类型ofsream和ostringstream都继承自ostream;类型fsream和stringstream都继承自iostream; 1、创建使用文件流对象 12345ifstream in(ifile);//构造一个ifstream并打开给定文件ofstream out;//构造输出文件流，未关联任何文件in.close();//关闭文件in.open(ifile + &quot;2&quot;);//打开另一个文件 ifstream,ofstream和fstream是实现文件读写操作的类型 案例 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;fstream&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char buffer[256]; ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误 if (! in.is_open())&#123; cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl; exit (1); &#125; vector&lt;string&gt; a; while (!in.eof())&#123; in.getline (buffer,100); //cout &lt;&lt; buffer &lt;&lt; endl; a.push_back(buffer); &#125; for(unsigned int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; resize(),reserve()resize()，设置大小（size）;reserve()，设置容量（capacity）;size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。 ifstreamcankao1、文件打开 1ifstream infile(fname,ios::in); 定义ifstream的对象infile,打开文件faname,ios::in是读取 打开文件的方式在ios类(所以流式I/O的基类)中定义 IO流的定义 含义 ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 2、关闭文件： 1infile.close 3、文本文件的读写 类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。 123456789101112131415161718192021222324252627282930313233343536373839写入内容：#include &lt;fiostream.h&gt; int main () &#123; ofstream out(&quot;out.txt&quot;); if (out.is_open()) &#123; out &lt;&lt; &quot;This is a line.\n&quot;; out &lt;&lt; &quot;This is another line.\n&quot;; out.close(); &#125; return 0; &#125; //结果: 在out.txt中写入： This is a line. This is another line读取内容：// reading a text file #include &lt;iostream.h&gt; #include &lt;fstream.h&gt; #include &lt;stdlib.h&gt; int main () &#123; char buffer[256]; ifstream in(&quot;test.txt&quot;); if (! in.is_open()) &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125; while (!in.eof() ) &#123; in.getline (buffer,100); cout &lt;&lt; buffer &lt;&lt; endl; &#125; return 0; &#125; //结果 在屏幕上输出 This is a line. This is another line``` 状态标识符 bad()如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。 fail()除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。 eof()如果读文件到达文件末尾，返回true。 good()这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。 123456要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。### sizeofsizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;[cankao](https://blog.csdn.net/tao20dage/article/details/52372604) 特性0：sizeof是运算符，不是函数特性1：sizeof不能求得void类型的长度特性2：sizeof能求得void类型的指针的长度特性3：sizeof能求得静态分配内存的数组的长度!特性4：sizeof不能求得动态分配的内存的大小!特性5：sizeof不能对不完整的数组求长度！特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！ 12345678910111213141516### new(std::nothrow) 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断 ### vector[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;在c++中，vector是一个十分有用的容器。作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;2、Vector作为函数的参数或者返回值时，需要注意它的写法： double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！ c++基本操作 1 、基本操作 (1)头文件#include.(2)创建vector对象，vector vec;(3)尾部插入数字：vec.push_back(a);(4)使用下标访问元素，cout&lt;&lt;vec[0]&lt;&lt;endl;记住下标是从0开始的。(5)使用迭代器访问元素.vector::iterator it;for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl;(6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;(7)删除元素： vec.erase(vec.begin()+2);删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始(8)向量大小:vec.size();(9)清空:vec.clear(); 123### 二维数组 #include “stdafx.h” #include &lt;cv.h&gt; #include #include using namespace std;int main(){ using namespace std; int out[3][2] = { 1, 2, 3, 4, 5, 6 }; vector &lt;int*&gt; v1; v1.push_back(out[0]); v1.push_back(out[1]); v1.push_back(out[2]); cout &lt;&lt; v1[0][0] &lt;&lt; endl;//1 cout &lt;&lt; v1[0][1] &lt;&lt; endl;//2 cout &lt;&lt; v1[1][0] &lt;&lt; endl;//3 cout &lt;&lt; v1[1][1] &lt;&lt; endl;//4 cout &lt;&lt; v1[2][0] &lt;&lt; endl;//5 cout &lt;&lt; v1[2][1] &lt;&lt; endl;//6 return 0;} 12345### 随机数RAND_MAX是C中stdlib.h中宏定义的一个字符常量：`#define RAND_MAX Ox7FFF`其值最小为32767,最大为2147483647 (double)rand() / RAND_MAX;//生成随机数```]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
