<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iPhone11 信息汇总]]></title>
    <url>%2F2019%2F09%2F11%2Fiphone11%2F</url>
    <content type="text"><![CDATA[北京时间9月11日，iPhone 11 系列正式发布，此次共有三款新机，分别是iPhone 11，iPhone 11 Pro，iPhone 11 Pro Max。 说明：笔者不对今年新款iPhone做评价，仅做简单陈述，无意贬低苹果或者其他友商，最后总结参考自PConline。 市场反响关注程度高不得不说虽然许多人称今年苹果发布会毫无新意，但是不得不说苹果关注度依然居高不下，这也说明苹果在手机界的影响力依然存在：苹果发布会第二天早上微博热搜前十苹果相关占6个 9月11日报道：iPhone 11天猫预约量暴增200％,绿色预约量最高源报道地址 外观：换色，换摄 没有任何意外，iPhone 11系列包含了三款产品，iPhone 11、iPhone 11 Pro以及iPhone 11 Pro Max。首先看看比较贵的两款机型，iPhone 11 Pro和iPhone 11 Pro Max，他们将是今年与安卓旗舰对标的主力。 不过官方公布的iPhone 11图片显然比之前曝光的iPhone图片要好看，而且虽然大致形状已经被提前剧透，但是实际iPhone 11外观依然与之前曝光的有所差距. 曝光图1:曝光图2:发布会图片1:发布会图片2: 机身正面设计，iPhone 11 Pro和iPhone 11 Pro Max给人的第一观感与上代机型几乎完全没有区别，同样的OLED材质、同样的窄边框设计、还有同样的刘海。 还好，用了两年刘海设计的iPhone还是凭借与边框几乎同宽的底边维持了耐看感，仔细揣摩，iPhone 11 Pro系列还是有了少许的升级，比如说，更强的屏幕，依旧是5.8英寸和6.5英寸，苹果将其称为“Super Retina XDR”的屏幕，458ppi，支持HDR、1200nit的峰值亮度，更高的对比度表现。 至于走量机型iPhone 11，毫无意外地维持Liquid Retina的LCD屏幕，虽然分辨率和旗舰手机会有点距离，但屏幕素质依旧出色，让用户“心甘情愿”为LCD埋单，屏幕尺寸为6.1英寸，刘海没有变小，与iPhone XR区别不大。 来到背面，全新iPhone 11系列在视觉上最大的变化就在这里，提供金色、深空灰色、银色、暗夜绿色共四色。3年的时间，苹果终于迈出了从双摄到三摄的一步。iPhone 11 Pro和iPhone 11 Pro Max均搭载后置三摄，虽然还是“祖传”1200万像素，但功能和外观有了不少的升级，至于这个“浴霸”外观，大家见仁见智吧。 走量机型iPhone 11终于让新iPhone全系多摄化，双摄加入，搭配多彩的机身设计，相信能够接下iPhone XR传来的一棒。 足足6种配色，iPhone 11让质感和设计并存：白色、黑色、红色、黄色，新加入的紫色、今年大热的绿色，当然也没有缺席。 全新iPhone 11系列的登场，给人感觉在外观方面少了一点惊喜：纵然浴霸外观革新了沿用两年的iPhone X系列设计；更小的刘海带来高屏占比，但都没有离开“稳扎稳打”的主旋律。 拍照：二摄/三摄 近几年，iPhone新品都重点在摄像头上面做文章，这次苹果iPhone 11 Pro与iPhone 11 Pro Max也不例外，相机硬件与软件体验全面升级，而两者的摄像头硬件配置一样。以前置摄像头为例子，配备了12MP TrueDepth镜头，支持全新升级慢动作视频和前置4K 60fps摄像，并支持人像模式。 后摄方面，三摄成员的一边，iPhone 11 Pro/iPhone 11 Pro Max的后置摄像头拥有全新的传感器，搭配1200万像素（广角，F/1.8，六镜式镜头）+1200万像素（长焦，F/2.0，六镜式镜头）+1200万像素（120°超广角，F/2.4，五镜式镜头 ）的组合，支持最高2倍光学变焦，广角与长焦镜头都搭载光学防抖，而在同一地方拍摄的时候，可以拍出三种不同的画面。 iPhone 11样张 软件方面，拥有人像模式，焦外成像和景深控制，以及人像光效，支持六种效果 (自然光、摄影室灯光、轮廓光、舞台光、单色舞台光和高调单色光)。大家期待的夜间模式，这次也终于配备。 如果你过去对iPhone的拍摄界面枯燥，这次应该会惊喜，苹果带来全新更具美感的沉浸式界面。 利用摄像头宽广的视角，可以看到取景框外的画面，体验更佳。 全新三摄系统 据了解，当苹果设计iPhone Pro摄像头的时候，希望超广角、广角与长焦这三个摄像头能同时运作。为了让不同模块呈现一致的效果，对每个摄像头的白平衡和曝光等参数，工程师都单独进行精确调校。 iPhone 11样张 在切换长焦、广角和超广角的流畅切换过程当中，利用了A13仿生运算能力。通过iPhone团队的合作，调校三摄协作的风格统一，大大提升相机的拍摄性能。 广角是这次iPhone 11 Pro家族的一大提升，取景范围高达四倍的超广角摄像头，可拍摄气势磅礴的场景，不论是妹子的大长腿，还是壮丽的山河景色，都可以尽收眼底。 4K视频 在A13处理器的协助下，iPhone 11 Pro支持扩展的动态范围和影院级防抖功能，可以录制4K 60fps的视频，而且后期剪辑工具也更好玩。 夜间模式 新的广角摄像头传感器让大众期待的“夜间模式得以实现”，通过智能的软件和A13仿生，用户只需要按下快门，就会自动生成明亮的画面效果，无惧黑夜。 左：未开启夜景模式 右：开启夜景模式 当系统检测到光线环境暗的时候，夜间模式会自动开启，借助光学防抖功能，拍摄多张这篇最终合成一张，类似安卓厂商宣传的多帧合成功能，例如在昏暗的晚宴，或者是光线环境一般的室外。 人像模式 在摄像头虚化方面，苹果一直领先不少安卓机型，而这次三个摄像头配合，广角可以拍摄更独特的样张，而当使用iOS 13的时候，里面有增加高调单色光效果，单色照符合个性鲜明的用户需求。 iPhone 11 Pro样张 苹果再次升级了智能HDR功能，称为“下一代智能HDR”，通过更灵敏的感光元件、增强的图像信号处理器和先进的算法，让照片中的高光和阴影细节更丰富。全新传感器拥有更低的弱光画面噪点，细节更丰富，优于前辈机型。 硬件：A13 Bionic/全系双卡/18W快充 Apple Arcade作为开场，性能无疑是苹果今年新设备的重点。 事实上，A系列处理器的强悍，确保了每年新iPhone在价格领先的同时也保持了性能领先。今年的新机照旧是“故技重演”，iPhone 11系列全系搭载全新的A13 Bionic处理器，配备神经网络引擎，继续发力苹果重视AR功能和AI体验。 旗舰处理器竞争已经不是当初两家之战，今年A13自然是卯足了劲。 A13 A13 Bionics采用4颗效率核心+2颗性能核心的组合，搭配4核心GPU，集成85亿个晶体管，性能提升了大约20％ 。苹果称其为“智能手机中最快的CPU”，有着“智能手机中最快的GPU”。 A13 Bionics搭载全新的人工智能核心Neural Engine，Apple表示该芯片的机器学习（ML）性能大幅提升，8核神经引擎能够执行1万亿每秒运算，“带来6倍性能升级。AI表现更加强大，无需让A13处理器“小材大用”，实现更出色的功效表现。当然，凭借苹果的优化，这些提升都会“无声无息”体现在你的日常体验里面。 由于现在iPhone未发售，所以也没有可靠的跑分，所以就拿发布会的几张图片分析一下：CPU对比： 笔者注：上图中CPU的对比应该是对比了单核性能差距(单核性能苹果与安卓阵营差距明显），多核性能差距并没有图中这么明显GPU对比： 顺便说一下，许多人说没有对比麒麟990，但是麒麟990依然使用Cortex-A76架构的大核和Mali-G76的GPU，并未采用Cortex-A77+Mali-G77（明年的高通865和三星已经官宣的Exyons980都采用了这一架构），而官方说法是A77架构能够提升20%的同频性能。因此华为990与980（同样采用Cortex-A76架构的大核和Mali-G76的GPU）差距并不大，主要是频率差异，官方说法是在整体性能表现会比上麒麟980提升10%左右，因此A13在CPU和GPU方面超越990是没问题的。 续航/充电 续航方面，iPhone 11系列的三台手机均提供不同程度的提升，iPhone 11 Pro Max较上代提升高达5小时续航、iPhone 11 Pro和iPhone 11则比他们的前辈iPhone XS和iPhone XR分别提升4小时和1小时续航，在提供强大性能的同时，带来更持久的使用体验。 说到续航，不得不提的就是iPhone历年被吐槽的充电，虽然发布会上没有说，但苹果官网消息显示，iPhone 11 Pro系列随附 18 瓦电源适配器，快充状态下约 30 分钟可充至 50% 电量；iPhone 11同样支持18W有线快充，官网特别提醒需使用 18 瓦或更大功率的电源适配器 (需单独购买)。 值得一提的是，今年的国行iPhone 11/iPhone 11 Pro和iPhone 11 Pro Max全系支持双卡功能，对于在上代iPhone XS纠结没有双卡的用户，这次大可放心入手较小屏幕的旗舰版本。 价格价格方面，iPhone 11国行起售价64GB版5499元；128GB版5999元；256GB版6799元。iPhone 11 Pro售价为64GB版8699元；256GB版9999元；顶配512GB版11799元，iPhone 11 Pro Max售价为64GB版9599元；256GB版10899元；顶配512GB版12699元。新机将在9月13日开始预购，9月20正式发售。iphone11与去年iPhone XR相比降了1000元。iPhone 11 Pro和iPhone 11 Pro Max则是与去年iPhone XS 和iPhone XS Max价格一致，考虑到iPhone 11 的美国价格是699美元，如果算上13%的增值税，应该会超过5500，因此今年iPhone 11的价格应该是针对中国市场作了调整（其余两款则保持原价）。因此与去年的iPhone XR相比iPhone 11加量还减价就显得性价比比较高了，如果不急着买，算上双11之类的促销最后应该可以5000以下拿下，性价比不错，相对应的iPhone XR的官网价格则下调到了4799。相比首发价下调1700，有需要的可以考虑。 总结 尽管升级不少，但全新的iPhone 11系列，却不能像以往那样给人一种打在安卓旗舰身上“拳拳到肉”的感觉，缺了什么呢？答案大家可能都知道，没有5G，或许会成为苹果今年挽回销量的一道坎。 5G永远在骚动，iPhone有恃无恐。今年的iPhone 11系列还能在5G前夕挽留人们的偏爱吗，还会出现“境泽言香”的局面吗？相信不久后，销量会告诉我们答案。 官网链接苹果官网 注本文图片来自网络，部分内容参考自PConline。]]></content>
      <tags>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F09%2F08%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown基本语法，适用Github,简书，Reddit等 主要内容 Markdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 Markdown相比WYSIWYG编辑器 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： &gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); }注意:需要和普通段落之间存在空行。 4.5 字体在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_要倾斜的文字左右分别用一个*号包起来 **粗体**，__粗体__要加粗的文字左右分别用两个*号包起来 ***斜体加粗***要倾斜和加粗的文字左右分别用三个*号包起来 ~~删除线~~要加删除线的文字左右分别用两个~~号包起来 效果： 斜体，斜体粗体，粗体这是斜体加粗的文字这是加删除线的文字 4.6 列表(表格)使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格或制表符_。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown MarkDownCopy https://github.com/younghz/Markdown 关于其它扩展语法可参见具体工具的使用说明。]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
        <tag>规范</tag>
        <tag>reddit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置]]></title>
    <url>%2F2019%2F09%2F08%2Ftheme_NextConfig1%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置 新建404界面在站点根目录下，输入hexo new page 404，在默认Hexo站点下/source/404/index.md打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态资源压缩静态资源压缩 在站点目录下安装插件： 1$ npm install gulp -g 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在Hexo站点下添加gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器： 123hexo ggulphexo d 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用&lt;!--与--&gt;隐藏之间的代码即可，或者直接删除。位置如图： 各版块透明度修改内容板块透明根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.content-wrap标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.header-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 站点概况背景根博客目录themes\next\source\css\_schemes\Pisces\_sidebar.styl文件.sidebar-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 修改然后根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.sidebar标签下background: $body-bg-color修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 网站底部字数统计具体方法实现 切换到根目录下，然后运行如下代码 1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可： 12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前： 123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 网页底部信息隐藏网页底默认最新一次使用，需要取消since注释，设定年份 1234567891011121314151617footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, `author` from Hexo main config will be used. copyright: by AomanHao #版权 显示文章阅读进度百分比设置方法：打开themes/next/_config.yml主题配置文件,找到# Scroll percent label in b2t button将scrollpercent:的值,改成true 12# Scroll percent label in b2t button scrollpercent: true 浏览页面的时候显示当前浏览进度如果想把top按钮放在侧边栏,打开themes/next下的_config.yml,搜索关键字b2t,把false改为true 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 1234567891011121314# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: appkey: notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page Hexo添加阅读次数next 集成了 leancloud 。可以在leancloud进行账号注册。创建一个新的应用。点击应用进入。创建名称为Counter的Class，名称必须为Counter 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next_config.yml打开主题配置文件 添加app_id 和app_key: 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: app_key: # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false Web安全性为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。 显示文章热度首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 设置方法：next主题集成leanCloud，打开themes/next/layout/_macro/post.swig,准备添加℃ 1234567891011121314&#123;# LeanCloud PageView #&#125;&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 插入摄氏度到倒数第三句，如下： 1&lt;span&gt;℃&lt;/span&gt; 打开，themes/next/languages/zh-CN.yml,将views后的文字描述改为热度. 1views: 热度 有的版本不一样，打开，themes/next/languages/zh-Hans.yml，将以下 1visitors: 热度 然后打开themes/next/_config.yml找到leancloud_visitors,将enable:改成true,再填上自己LeanCloud的app_id和app_key。 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: 你自己的id app_key: 你自己的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false 添加网站已运行时间在themes/layout/_parrials/footer.swing后添加 1234567891011121314151617&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("11/27/2017 12:00:00");//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = " Runing "+dnum+" D "; document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S"; &#125; setInterval("createtime()",250);&lt;/script&gt; 添加头像打开themes/next下的_config.yml文件，搜索 Avatar关键字，修改url的参数 1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url链接默认是themes/next/source/images下的avatar.gif文件,有两种方法修改连接 1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间 12345url: /images/avatar.gif或者url: /images/xx.jpg等类型图片 2、图床外链，建议使用 1url: http://example.com/avatar.png 添加站内搜索设置效果： 设置方法：安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 底部跳动图标实现注意点：需要到next\layout_partials下的footer.swig文件中，在你所需要调动的图标所对应的span中增加对应的ID去到主体的css文件（next\source\css_variables\custom.styl，增加以下代码即可 123456789101112131415//底部爱心小图标跳动keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;//图标所对应的span中的ID#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 113);&#125; 实现统计功能具体实现方法:在根目录下安装 hexo-wordcount,运行： 1npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css\_custom的custom.styl添加下面参数 12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大数据算法排序]]></title>
    <url>%2F2019%2F09%2F06%2F10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C%2B%2B%2F</url>
    <content type="text"><![CDATA[语言：Java、C++ 排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 用一张图概括： 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 1. 冒泡排序1.1 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1.2 动画演示 1.3 参考代码1234567891011121314151617181920212223242526272829// Java 代码实现public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 2. 选择排序2.1 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2.2 动画演示 2.3 参考代码123456789101112131415161718192021222324252627282930//Java 代码实现public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 3. 插入排序3.1 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 3.2 动画演示 3.3 参考代码123456789101112131415161718192021222324252627282930//Java 代码实现public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 4. 希尔排序4.1 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动画演示 4.3 参考代码1234567891011121314151617181920212223242526272829//Java 代码实现public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 5. 归并排序5.1 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 5.2 动画演示 5.3 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; C++代码：cankao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn=500000,INF=0x3f3f3f3f;int L[maxn/2+2],R[maxn/2+2];void merge(int a[],int n,int left,int mid,int right)&#123; int n1=mid-left,n2=right-mid; for(int i=0;i&lt;n1;i++) L[i]=a[left+i]; for(int i=0;i&lt;n2;i++) R[i]=a[mid+i]; L[n1]=R[n2]=INF; int i=0,j=0; for(int k=left;k&lt;right;k++) &#123; if(L[i]&lt;=R[j]) a[k]=L[i++]; else a[k]=R[j++]; &#125;&#125;void mergesort(int a[],int n,int left,int right)&#123; if(left+1&lt;right) &#123; int mid=(left+right)/2; mergesort(a,n,left,mid); mergesort(a,n,mid,right); merge(a,n,left,mid,right); &#125;&#125;int main()&#123; int a[maxn],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; mergesort(a,n,0,n); for(int i=0;i&lt;n;i++) &#123; if(i) cout&lt;&lt;" "; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 6. 快速排序6.1 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 6.2 动画演示 6.3 参考代码Java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041//Java 代码实现public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; C++代码：cankao 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;int main()&#123; int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k; int len=sizeof(array)/sizeof(int); cout&lt;&lt;"The orginal arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; quickSort(array,0,len-1); cout&lt;&lt;"The sorted arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; system("pause"); return 0;&#125; void quickSort(int s[], int low, int high)&#123; if (low&lt; high) &#123; int i = low, j = high, x = s[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quickSort(s, low, i - 1); // 递归调用 quickSort(s, i + 1, high); &#125;&#125; 7. 堆排序7.1 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 7.2 动画演示 7.3 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Java 代码实现public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 8. 计数排序8.1 算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 8.2 动画演示 8.3 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142//Java 代码实现public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 9. 桶排序9.1 算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果 9.2 动画演示 9.3 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Java 代码实现public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 10. 基数排序10.1 算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 10.2 动画演示 10.3 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Java 代码实现public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2019%2F09%2F05%2FC%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[C++入门 指针入门 指针作用： 引用类型，传递地址，减少内存消耗案例int p &gt;定义变量pint* p &gt;定义指针变量p使用指针，先要定义指针变量 12345678#include&lt;stdio.h&gt;int main() &#123; int *p; //int* p &gt;定义指针变量p int a=3; p=&amp;a; //&amp;a是把a的地址赋给指针p，&amp;：取址符a printf(&quot;%d\n&quot;,*p) //输出为3 return 0; &#125; 123&amp; 取变量的地址 &amp;(变量名)* 指针运算符（取值运算） *(变量名)&amp; *互为逆运算 *(&amp;(int i =6))=6 指针变量是存储地址的变量，随机分配例如： 123456int *p1;char *nameint x;int *p; p=&amp;x;答：*P=3;p是x的地址，*p是x的值 常用错误：1、指针不能直接复制 123456789错误：int *p; p =100;//错误正确：int i, *p, *t;p=&amp;i;t=p;*p *t是指针，把i的地址赋给pt指针（元素地址） 2、不能直接给指针赋值(不能直接变量取值) 12int x= 20;printf(&quot;%d,&amp;(*x)); Scanf函数:函数后的参数应该传入指针，不应该是值 123int score;printf(&quot;shuru :\n&quot;);scanf(&quot;%d&quot;,score); Swap函数： 12345678910111213141516171819#include&lt;stdio.h&gt;void swap(int *x, int *y)&#123; int temp;//中间变量 temp=*x; *x = *y; *y = temp; printf(&quot;x=%d, y=%d \n&quot;, *x, *y);&#125;main()&#123; int i =13, j =45; swap(&amp;i, &amp;j); printf(&quot;i=%d, j=%d\n&quot;,i ,j);&#125;//输出： x=45,y=13 i=45,j=13 二级指针 C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。只有一个号的时候，我们叫它一级指针。* 两个星号的叫二级指针。 123456789101112131415void swap ( int *a, int *b )&#123; int c; c = *a; *a = *b; *b = c; &#125; int main(int argc, char **argv)&#123; int a,b; a = 16; b = 32; swap( &amp;a, &amp;b); return ( a - b ); &#125; 段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数 我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下 12345p中放的是中间桥梁bridge的地址&amp;bridge*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，**p就是目标操作数中间的bridge是桥梁，中间件使用的，过度吧 双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。 输入输出流IO库：|头文件|类型||||-|-|-|-||iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流||fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件||sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string| 123类型ifsream和istringstream都继承自istream;类型ofsream和ostringstream都继承自ostream;类型fsream和stringstream都继承自iostream; 1、创建使用文件流对象 12345ifstream in(ifile);//构造一个ifstream并打开给定文件ofstream out;//构造输出文件流，未关联任何文件in.close();//关闭文件in.open(ifile + &quot;2&quot;);//打开另一个文件 ifstream,ofstream和fstream是实现文件读写操作的类型 案例 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;fstream&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char buffer[256]; ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误 if (! in.is_open())&#123; cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl; exit (1); &#125; vector&lt;string&gt; a; while (!in.eof())&#123; in.getline (buffer,100); //cout &lt;&lt; buffer &lt;&lt; endl; a.push_back(buffer); &#125; for(unsigned int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; resize(),reserve()resize()，设置大小（size）;reserve()，设置容量（capacity）;size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。 ifstreamcankao1、文件打开 1ifstream infile(fname,ios::in); 定义ifstream的对象infile,打开文件faname,ios::in是读取 打开文件的方式在ios类(所以流式I/O的基类)中定义 IO流的定义 含义 ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 2、关闭文件： 1infile.close 3、文本文件的读写 类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。 123456789101112131415161718192021222324252627282930313233343536373839写入内容：#include &lt;fiostream.h&gt; int main () &#123; ofstream out(&quot;out.txt&quot;); if (out.is_open()) &#123; out &lt;&lt; &quot;This is a line.\n&quot;; out &lt;&lt; &quot;This is another line.\n&quot;; out.close(); &#125; return 0; &#125; //结果: 在out.txt中写入： This is a line. This is another line读取内容：// reading a text file #include &lt;iostream.h&gt; #include &lt;fstream.h&gt; #include &lt;stdlib.h&gt; int main () &#123; char buffer[256]; ifstream in(&quot;test.txt&quot;); if (! in.is_open()) &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125; while (!in.eof() ) &#123; in.getline (buffer,100); cout &lt;&lt; buffer &lt;&lt; endl; &#125; return 0; &#125; //结果 在屏幕上输出 This is a line. This is another line``` 状态标识符 bad()如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。 fail()除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。 eof()如果读文件到达文件末尾，返回true。 good()这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。 123456要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。### sizeofsizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;[cankao](https://blog.csdn.net/tao20dage/article/details/52372604) 特性0：sizeof是运算符，不是函数特性1：sizeof不能求得void类型的长度特性2：sizeof能求得void类型的指针的长度特性3：sizeof能求得静态分配内存的数组的长度!特性4：sizeof不能求得动态分配的内存的大小!特性5：sizeof不能对不完整的数组求长度！特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！ 12345678910111213141516### new(std::nothrow) 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断 ### vector[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;在c++中，vector是一个十分有用的容器。作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;2、Vector作为函数的参数或者返回值时，需要注意它的写法： double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！ c++基本操作 1 、基本操作 (1)头文件#include.(2)创建vector对象，vector vec;(3)尾部插入数字：vec.push_back(a);(4)使用下标访问元素，cout&lt;&lt;vec[0]&lt;&lt;endl;记住下标是从0开始的。(5)使用迭代器访问元素.vector::iterator it;for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl;(6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;(7)删除元素： vec.erase(vec.begin()+2);删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始(8)向量大小:vec.size();(9)清空:vec.clear(); 123### 二维数组 #include “stdafx.h” #include &lt;cv.h&gt; #include #include using namespace std;int main(){ using namespace std; int out[3][2] = { 1, 2, 3, 4, 5, 6 }; vector &lt;int*&gt; v1; v1.push_back(out[0]); v1.push_back(out[1]); v1.push_back(out[2]); cout &lt;&lt; v1[0][0] &lt;&lt; endl;//1 cout &lt;&lt; v1[0][1] &lt;&lt; endl;//2 cout &lt;&lt; v1[1][0] &lt;&lt; endl;//3 cout &lt;&lt; v1[1][1] &lt;&lt; endl;//4 cout &lt;&lt; v1[2][0] &lt;&lt; endl;//5 cout &lt;&lt; v1[2][1] &lt;&lt; endl;//6 return 0;} 12345### 随机数RAND_MAX是C中stdlib.h中宏定义的一个字符常量：`#define RAND_MAX Ox7FFF`其值最小为32767,最大为2147483647 (double)rand() / RAND_MAX;//生成随机数```]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
