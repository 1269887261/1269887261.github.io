<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F09%2F08%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown基本语法，适用Github,简书，Reddit等 主要内容 Markdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 Markdown相比WYSIWYG编辑器 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： &gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); }注意:需要和普通段落之间存在空行。 4.5 字体在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_要倾斜的文字左右分别用一个*号包起来 **粗体**，__粗体__要加粗的文字左右分别用两个*号包起来 ***斜体加粗***要倾斜和加粗的文字左右分别用三个*号包起来 ~~删除线~~要加删除线的文字左右分别用两个~~号包起来 效果： 斜体，斜体粗体，粗体这是斜体加粗的文字这是加删除线的文字 4.6 列表(表格)使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格或制表符_。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown MarkDownCopy https://github.com/younghz/Markdown 关于其它扩展语法可参见具体工具的使用说明。]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
        <tag>规范</tag>
        <tag>reddit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置]]></title>
    <url>%2F2019%2F09%2F08%2Ftheme_NextConfig1%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置 新建404界面在站点根目录下，输入hexo new page 404，在默认Hexo站点下/source/404/index.md打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态资源压缩静态资源压缩 在站点目录下安装插件： 1$ npm install gulp -g 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在Hexo站点下添加gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩html文件gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/demo 目录内图片gulp.task('minify-images', function() &#123; gulp.src('./public/demo/**/*.*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器： 123hexo ggulphexo d 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用&lt;!--与--&gt;隐藏之间的代码即可，或者直接删除。位置如图： 各版块透明度修改内容板块透明根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.content-wrap标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.header-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 站点概况背景根博客目录themes\next\source\css\_schemes\Pisces\_sidebar.styl文件.sidebar-inner标签下background: white修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 修改然后根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.sidebar标签下background: $body-bg-color修改为： 1background: rgba(255,255,255,0.7); //0.7是透明度 网站底部字数统计具体方法实现 切换到根目录下，然后运行如下代码 1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可： 12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前： 123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 网页底部信息隐藏网页底默认最新一次使用，需要取消since注释，设定年份 1234567891011121314151617footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, `author` from Hexo main config will be used. copyright: by AomanHao #版权 显示文章阅读进度百分比设置方法：打开themes/next/_config.yml主题配置文件,找到# Scroll percent label in b2t button将scrollpercent:的值,改成true 12# Scroll percent label in b2t button scrollpercent: true 浏览页面的时候显示当前浏览进度如果想把top按钮放在侧边栏,打开themes/next下的_config.yml,搜索关键字b2t,把false改为true 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 1234567891011121314# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: appkey: notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page Hexo添加阅读次数next 集成了 leancloud 。可以在leancloud进行账号注册。创建一个新的应用。点击应用进入。创建名称为Counter的Class，名称必须为Counter 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next_config.yml打开主题配置文件 添加app_id 和app_key: 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: app_key: # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false Web安全性为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。 显示文章热度首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 设置方法：next主题集成leanCloud，打开themes/next/layout/_macro/post.swig,准备添加℃ 1234567891011121314&#123;# LeanCloud PageView #&#125;&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 插入摄氏度到倒数第三句，如下： 1&lt;span&gt;℃&lt;/span&gt; 打开，themes/next/languages/zh-CN.yml,将views后的文字描述改为热度. 1views: 热度 有的版本不一样，打开，themes/next/languages/zh-Hans.yml，将以下 1visitors: 热度 然后打开themes/next/_config.yml找到leancloud_visitors,将enable:改成true,再填上自己LeanCloud的app_id和app_key。 1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: 你自己的id app_key: 你自己的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false 添加网站已运行时间在themes/layout/_parrials/footer.swing后添加 1234567891011121314151617&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("11/27/2017 12:00:00");//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = " Runing "+dnum+" D "; document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S"; &#125; setInterval("createtime()",250);&lt;/script&gt; 添加头像打开themes/next下的_config.yml文件，搜索 Avatar关键字，修改url的参数 1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url链接默认是themes/next/source/images下的avatar.gif文件,有两种方法修改连接 1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间 12345url: /images/avatar.gif或者url: /images/xx.jpg等类型图片 2、图床外链，建议使用 1url: http://example.com/avatar.png 添加站内搜索设置效果： 设置方法：安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 底部跳动图标实现注意点：需要到next\layout_partials下的footer.swig文件中，在你所需要调动的图标所对应的span中增加对应的ID去到主体的css文件（next\source\css_variables\custom.styl，增加以下代码即可 123456789101112131415//底部爱心小图标跳动keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;//图标所对应的span中的ID#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 113);&#125; 实现统计功能具体实现方法:在根目录下安装 hexo-wordcount,运行： 1npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css\_custom的custom.styl添加下面参数 12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大数据算法排序]]></title>
    <url>%2F2019%2F09%2F06%2F10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C%2B%2B%2F</url>
    <content type="text"><![CDATA[10大数据算法排序Java_C++ 冒泡排序 依次比较n与后面的数字，大的放右面，小的放左边 Java代码 12345678910111213141516171819202122232425/** * 冒泡排序 * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * @param numbers 需要排序的整型数组 */ public static void bubbleSort(int[] numbers) &#123; int temp = 0; int size = numbers.length; for(int i = 0 ; i &lt; size-1; i ++) &#123; for(int j = 0 ;j &lt; size-1-i ; j++) &#123; if(numbers[j] &gt; numbers[j+1]) //交换两数位置 &#123; temp = numbers[j]; numbers[j] = numbers[j+1]; numbers[j+1] = temp; &#125; &#125; &#125; &#125; C++代码 1待补充 选择排序 选择n个数组成的数组arr里最大的一个数，放在arr[n-1]，然后维数n-1选择前n-1个数组成的数组，取最大数，放在arr Java代码： 1234567891011121314151617181920212223242526272829/** * 选择排序算法 * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * @param numbers */ public static void selectSort(int[] numbers) &#123; int size = numbers.length; //数组长度 int temp = 0 ; //中间变量 for(int i = 0 ; i &lt; size ; i++) &#123; int k = i; //待确定的位置 //选择出应该在第i个位置的数 for(int j = size -1 ; j &gt; i ; j--) &#123; if(numbers[j] &lt; numbers[k]) &#123; k = j; &#125; &#125; //交换两个数 temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; &#125; &#125; C++代码： 1待补充 快速排序及其改进算法C++实现 快速排序可以看成是插入排序的改进，它是一种分治的排序算法 Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FastSort&#123; public static void main(String []args)&#123; System.out.println("Hello World"); int[] a = &#123;12,20,5,16,15,1,30,45,23,9&#125;; int start = 0; int end = a.length-1; sort(a,start,end); for(int i = 0; i&lt;a.length; i++)&#123; System.out.println(a[i]); &#125; &#125; public void sort(int[] a,int low,int high)&#123; int start = low; int end = high; int key = a[low]; while(end&gt;start)&#123; //从后往前比较 while(end&gt;start&amp;&amp;a[end]&gt;=key) //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较 end--; if(a[end]&lt;=key)&#123; int temp = a[end]; a[end] = a[start]; a[start] = temp; &#125; //从前往后比较 while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置 start++; if(a[start]&gt;=key)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用 &#125; //递归 if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1 if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个 &#125; &#125; C++代码：cankao 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;int main()&#123; int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k; int len=sizeof(array)/sizeof(int); cout&lt;&lt;"The orginal arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; quickSort(array,0,len-1); cout&lt;&lt;"The sorted arrayare:"&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;","; cout&lt;&lt;endl; system("pause"); return 0;&#125; void quickSort(int s[], int low, int high)&#123; if (low&lt; high) &#123; int i = low, j = high, x = s[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quickSort(s, low, i - 1); // 递归调用 quickSort(s, i + 1, high); &#125;&#125; 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。分治思想：合并步骤如下 Java代码：cankao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sortdemo;import java.util.Arrays;/** * Created by chengxiao on 2016/12/8. */public class MergeSort &#123; public static void main(String []args)&#123; int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 sort(arr,0,arr.length-1,temp); &#125; private static void sort(int[] arr,int left,int right,int []temp)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序 sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序 merge(arr,left,mid,right,temp);//将两个有序子数组合并操作 &#125; &#125; private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i = left;//左序列指针 int j = mid+1;//右序列指针 int t = 0;//临时数组指针 while (i&lt;=mid &amp;&amp; j&lt;=right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++] = arr[i++]; &#125;else &#123; temp[t++] = arr[j++]; &#125; &#125; while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; //将temp中的元素全部拷贝到原数组中 while(left &lt;= right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; C++代码：cankao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn=500000,INF=0x3f3f3f3f;int L[maxn/2+2],R[maxn/2+2];void merge(int a[],int n,int left,int mid,int right)&#123; int n1=mid-left,n2=right-mid; for(int i=0;i&lt;n1;i++) L[i]=a[left+i]; for(int i=0;i&lt;n2;i++) R[i]=a[mid+i]; L[n1]=R[n2]=INF; int i=0,j=0; for(int k=left;k&lt;right;k++) &#123; if(L[i]&lt;=R[j]) a[k]=L[i++]; else a[k]=R[j++]; &#125;&#125;void mergesort(int a[],int n,int left,int right)&#123; if(left+1&lt;right) &#123; int mid=(left+right)/2; mergesort(a,n,left,mid); mergesort(a,n,mid,right); merge(a,n,left,mid,right); &#125;&#125;int main()&#123; int a[maxn],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; mergesort(a,n,0,n); for(int i=0;i&lt;n;i++) &#123; if(i) cout&lt;&lt;" "; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 堆排序 http://www.cnblogs.com/MOBIN/p/5374217.html 堆排序主要在于理解堆的构造过程和在输出最大元素后如何对堆进行重新调整 左右父节点下标: 123左：i*2+1右：i*2+2父：(i-1)/2 Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class HeapSort &#123;private static void heapSort(int[] arr) &#123;int len = arr.length -1;//堆构造，调整结构，符合大顶堆或者小顶堆for(int i = len/2 ; i &gt;=0; i --)&#123; heapAdjust(arr,i,len);&#125;while (len &gt;=0)&#123;swap(arr,0,len--); //将堆顶元素与尾节点交换后，长度减1，尾元素最大heapAdjust(arr,0,len); //再次对堆进行调整&#125;&#125;public static void heapAdjust(int[] arr,int i,int len)&#123;int left = 2*i+1,right = 2*i+2,largest = i;if(left &lt;= len &amp;&amp; arr[left] &gt; arr[i])largest = left;if(right &lt;= len &amp;&amp; arr[right] &gt; arr[largest])largest = right;if(largest != i) &#123;swap(arr, i, largest);heapAdjust(arr,largest,len);&#125;&#125;public static void swap(int[] arr,int i,int len)&#123;int temp = arr[i];arr[i] = arr[len];arr[len] = temp;&#125;public static void main(String[] args) &#123;int array[] = &#123;20,50,20,40,70,10,80,30,60&#125;;System.out.println("排序之前：");for(int element : array)&#123;System.out.print(element+" ");&#125;heapSort(array);System.out.println("\n排序之后：");for(int element : array)&#123;System.out.print(element+" ");&#125;&#125;&#125; 桶排序需要求数组中的最大数1、桶排序不在是一种基于比较的排序方法，而是需要待排序列满足以下两个条件： 1、待排序列的值处于一个可枚举的范围内2、待排序列所在可枚举范围不应太大，不然开销会很大。 原理： 假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。 桶排序适用场景:根据桶排序的特点，桶排序一般适用于一些特定的环境，比如数据范围较为局限或者有一些特定的要求，比如需要通过哈希映射快速获取某些值，需要统计每个数的数量。但是这一切都以确认数据的范围为前提，如果范围跨度过大，则考虑用其他算法。 Java代码： /// &lt;summary&gt; /// 桶排序 /// ///如果有重复的数字,则需要 List&lt;int&gt;数组,这里举的例子没有重复的数字 /// &lt;/summary&gt; /// &lt;param name="unsorted"&gt;待排数组&lt;/param&gt; /// &lt;param name="maxNumber"&gt;待排数组中的最大数,如果可以提供的话&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static int[] bucket_sort(int[] unsorted, int maxNumber = 97) { int[] sorted = new int[maxNumber + 1]; for (int i = 0; i &lt; unsorted.Length; i++) { sorted[unsorted[i]] = unsorted[i]; } return sorted; } static void Main(string[] args) { int[] x = {49、 38 、 35、 97 、 76、 73 、 27、 49 }; var sorted = bucket_sort(x, 97); for (int i = 0; i &lt; sorted.Length; i++) { if (sorted[i] &gt; 0) Console.WriteLine(sorted[i]); } Console.ReadLine(); }]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2019%2F09%2F05%2FC%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[C++入门 指针入门 指针作用： 引用类型，传递地址，减少内存消耗案例int p &gt;定义变量pint* p &gt;定义指针变量p使用指针，先要定义指针变量 12345678#include&lt;stdio.h&gt;int main() &#123; int *p; //int* p &gt;定义指针变量p int a=3; p=&amp;a; //&amp;a是把a的地址赋给指针p，&amp;：取址符a printf(&quot;%d\n&quot;,*p) //输出为3 return 0; &#125; 123&amp; 取变量的地址 &amp;(变量名)* 指针运算符（取值运算） *(变量名)&amp; *互为逆运算 *(&amp;(int i =6))=6 指针变量是存储地址的变量，随机分配例如： 123456int *p1;char *nameint x;int *p; p=&amp;x;答：*P=3;p是x的地址，*p是x的值 常用错误：1、指针不能直接复制 123456789错误：int *p; p =100;//错误正确：int i, *p, *t;p=&amp;i;t=p;*p *t是指针，把i的地址赋给pt指针（元素地址） 2、不能直接给指针赋值(不能直接变量取值) 12int x= 20;printf(&quot;%d,&amp;(*x)); Scanf函数:函数后的参数应该传入指针，不应该是值 123int score;printf(&quot;shuru :\n&quot;);scanf(&quot;%d&quot;,score); Swap函数： 12345678910111213141516171819#include&lt;stdio.h&gt;void swap(int *x, int *y)&#123; int temp;//中间变量 temp=*x; *x = *y; *y = temp; printf(&quot;x=%d, y=%d \n&quot;, *x, *y);&#125;main()&#123; int i =13, j =45; swap(&amp;i, &amp;j); printf(&quot;i=%d, j=%d\n&quot;,i ,j);&#125;//输出： x=45,y=13 i=45,j=13 二级指针 C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。只有一个号的时候，我们叫它一级指针。* 两个星号的叫二级指针。 123456789101112131415void swap ( int *a, int *b )&#123; int c; c = *a; *a = *b; *b = c; &#125; int main(int argc, char **argv)&#123; int a,b; a = 16; b = 32; swap( &amp;a, &amp;b); return ( a - b ); &#125; 段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数 我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下 12345p中放的是中间桥梁bridge的地址&amp;bridge*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，**p就是目标操作数中间的bridge是桥梁，中间件使用的，过度吧 双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。 输入输出流IO库：|头文件|类型||||-|-|-|-||iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流||fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件||sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string| 123类型ifsream和istringstream都继承自istream;类型ofsream和ostringstream都继承自ostream;类型fsream和stringstream都继承自iostream; 1、创建使用文件流对象 12345ifstream in(ifile);//构造一个ifstream并打开给定文件ofstream out;//构造输出文件流，未关联任何文件in.close();//关闭文件in.open(ifile + &quot;2&quot;);//打开另一个文件 ifstream,ofstream和fstream是实现文件读写操作的类型 案例 12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;fstream&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char buffer[256]; ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误 if (! in.is_open())&#123; cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl; exit (1); &#125; vector&lt;string&gt; a; while (!in.eof())&#123; in.getline (buffer,100); //cout &lt;&lt; buffer &lt;&lt; endl; a.push_back(buffer); &#125; for(unsigned int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; resize(),reserve()resize()，设置大小（size）;reserve()，设置容量（capacity）;size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。 ifstreamcankao1、文件打开 1ifstream infile(fname,ios::in); 定义ifstream的对象infile,打开文件faname,ios::in是读取 打开文件的方式在ios类(所以流式I/O的基类)中定义 IO流的定义 含义 ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 2、关闭文件： 1infile.close 3、文本文件的读写 类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。 123456789101112131415161718192021222324252627282930313233343536373839写入内容：#include &lt;fiostream.h&gt; int main () &#123; ofstream out(&quot;out.txt&quot;); if (out.is_open()) &#123; out &lt;&lt; &quot;This is a line.\n&quot;; out &lt;&lt; &quot;This is another line.\n&quot;; out.close(); &#125; return 0; &#125; //结果: 在out.txt中写入： This is a line. This is another line读取内容：// reading a text file #include &lt;iostream.h&gt; #include &lt;fstream.h&gt; #include &lt;stdlib.h&gt; int main () &#123; char buffer[256]; ifstream in(&quot;test.txt&quot;); if (! in.is_open()) &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125; while (!in.eof() ) &#123; in.getline (buffer,100); cout &lt;&lt; buffer &lt;&lt; endl; &#125; return 0; &#125; //结果 在屏幕上输出 This is a line. This is another line``` 状态标识符 bad()如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。 fail()除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。 eof()如果读文件到达文件末尾，返回true。 good()这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。 123456要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。### sizeofsizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;[cankao](https://blog.csdn.net/tao20dage/article/details/52372604) 特性0：sizeof是运算符，不是函数特性1：sizeof不能求得void类型的长度特性2：sizeof能求得void类型的指针的长度特性3：sizeof能求得静态分配内存的数组的长度!特性4：sizeof不能求得动态分配的内存的大小!特性5：sizeof不能对不完整的数组求长度！特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！ 12345678910111213141516### new(std::nothrow) 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断 ### vector[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;在c++中，vector是一个十分有用的容器。作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;2、Vector作为函数的参数或者返回值时，需要注意它的写法： double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！ c++基本操作 1 、基本操作 (1)头文件#include.(2)创建vector对象，vector vec;(3)尾部插入数字：vec.push_back(a);(4)使用下标访问元素，cout&lt;&lt;vec[0]&lt;&lt;endl;记住下标是从0开始的。(5)使用迭代器访问元素.vector::iterator it;for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl;(6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;(7)删除元素： vec.erase(vec.begin()+2);删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始(8)向量大小:vec.size();(9)清空:vec.clear(); 123### 二维数组 #include “stdafx.h” #include &lt;cv.h&gt; #include #include using namespace std;int main(){ using namespace std; int out[3][2] = { 1, 2, 3, 4, 5, 6 }; vector &lt;int*&gt; v1; v1.push_back(out[0]); v1.push_back(out[1]); v1.push_back(out[2]); cout &lt;&lt; v1[0][0] &lt;&lt; endl;//1 cout &lt;&lt; v1[0][1] &lt;&lt; endl;//2 cout &lt;&lt; v1[1][0] &lt;&lt; endl;//3 cout &lt;&lt; v1[1][1] &lt;&lt; endl;//4 cout &lt;&lt; v1[2][0] &lt;&lt; endl;//5 cout &lt;&lt; v1[2][1] &lt;&lt; endl;//6 return 0;} 12345### 随机数RAND_MAX是C中stdlib.h中宏定义的一个字符常量：`#define RAND_MAX Ox7FFF`其值最小为32767,最大为2147483647 (double)rand() / RAND_MAX;//生成随机数```]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
